This algorithm borrows heavily from Figure 5-27 in the text.

==============================================================================
@ INITIALIZING PHASE
==============================================================================

@ Initialize GPIO 91 as an input and rising edge detect

	@ Word to clear bit 91, sign off when output
	@ Write to GPCR2
	@ Read GPDR2 to get current value
	@ Clear bit (11) to make GPIO 91 an input
	@ Write word back to the GPDR2
	@ Load address of GRER2 register
	@ Read current value of GRER2 register
	@ Load mask to set bit (11)
	@ Set bit (11)
	@ Write word back to GRER2 register

@ Initialize GPIO 10 as a rising edge interrupt detect for COM2 UART

	@ Point to GRER0 register
	@ Read GRER0 register
	@ Set bit (19) to enable GPIO10 for rising edge detect
	@ Write back to GRER0

@ Initalize the UART
@ Set DLAB bit in LCR to access Baud Rate Divisor

	@ Point to UART LCR
	@ Value for divisor enable = 1, 8 bits, no parity, 1 stop bit
	@ Write to LCR

@ Load divisor value to give 38.4k b/s

	@ Pointer to DLL
	@ #0x18 for 38.4 kb/s
	@ Write to DLL
	@ Value for DLM 
	@ Pre-index to write to DLM

@ Toggle DLAB bit back to 0 to give access to Tx and Rx registers

	@ Point to UART LCR
	@ Value for divisor enable = 0, 8 bits, no parity, 1 stop bit
	@ Write to LCR

@ Enable Tx interrupt and enable modem status change interrupt

	@ Pointer to IER
	@ Bit 3 = CTS, bit 1 = THR
	@ Write to IER

@ Clear FIFO and turn off FIFO mode

	@ Pointer to FCR
	@ Value to disable FIFO and clear FIFO
	@ Write to FCR

@ Initialize interrupt controller for button and UART on IP<10>

	@ Load address of mask (ICMR) register
	@ Read current value of ICMR
	@ Load value of unmask bit 10 for GPIO82:2
	@ Set bit 10 to unmask IM10
	@ Write word back to ICMR register

@ Hook IRQ procedure address and install out IRQ_DIRECTOR address

	@ Load IRQ interrupt vector address 0x18
	@ Read instr from interrupt vector table at 0x18
	@ Construct mask
	@ Mask all but offset part of instruction
	@ Build absolute address of IRQ procedure in literal pool
	@ Read BTLDR IRQ address from literal pool
	@ Save BTLDR IRQ address for use in IRQ_DIRECTOR	
	@ Load absolute address of our interrupt director	
	@ Store this address literal pool

@ Make sure IRQ interrupt on processor enabled by clearing bit 7 in CPSR

	@ Copy CPSR to R3
	@ Clear bit 7 (IRQ Enable bit)
	@ Write new counter value back in memory

==============================================================================
@ RUNTIME PHASE
==============================================================================

@ Wait in the main loop for an interrupt

	@ LOOP

@ An interrupt has been detected! Test it to determine a source.
@ IRQ_DIRECTOR

INT_DIRECTOR:
		@ Save registers on stack
		@ Assume only GPIO 119:2 possible for this program.
		@ System will take care of others.
		@ Point at IRQ pending register (ICIP)
		@ Read ICIP
		@ Check if GPIO 119:2 IRQ interrup ton IS<10> asserted
B-- PASSON	@ No, must be other iRQ, pass on to system program
		@ Load address of GEDR0 register
		@ Read GEDR0 register address to check if GPIO10 
		@ Check for UART interrupt on bit <19>
B-- TLK_SVC	@ Yes, go send character
		@ If no, check for button.
		@ Load GEDR2 register address to check if GPIO91
		@ Read GEDR2 register value
		@ Check if bit <11> in GEDR2 = 1
B-- BTN_SVC	@ Yes, must be button press
		@ Go service the button - return to wait loop from SVC
		@ No, must be other GPIO 119:2 IRQ, pass on. 

@ The interrupt is not from our button or the UART
@ PASS ON

		@ Restore the registers
		@ Go to bootloader IRQ service procedure
		@ Bootloader will use restored LR to return to loop from SVC.

@ The interrupt came from our button on GPIO pin 91
@ BTN_SVC

		@ Value to clear bit <11> in GEDR2
		@ This will also reset bit 10 in ICPR and ICIP
		@      if no other GPIO 119:2 interrupts
		@ Write to GEDR2.
		@ Pointer to the MCR to enable UART interrupt and assert
		@      CTS# to send message to talker.
		@ Enable UART interrupt
		@ Write back to MCR
		@ Restore registers, including return address
		@ Return from interrupt to wait loop

@ The interrupt came from the CTS# low or THR empty or other interrupt
@ TLKR_SVC

		@ Save additional registers
		@ Point to MSR
		@ Read MSR, resets MSR change interrupt bits
		@ Check if the CTS# is currently asserted (MSR bit <4>)
BEQ NOCTS	@ If not, go check for THR status
		@ CTS asserted, read LSR (does not clear interrupt)
		@ Check if THR-ready is asserted
BEQ GOBCK	@ If no, exit and wait for THR-ready
B SEND		@ If yes, both are asserted, send character

@ The interrupt did not come from CTS# low
@ NOCTS

		@ Point to LSR
		@ Read LSR (does not clear interrupt)
		@ Check if THR-ready is asserted
B-- GOBCK	@ Neither CTS or THR are asserted, must be other source
		@ Else no CTS# but THR asserted, disable interrupt on THR
		@       to prevent spinning while waiting for CTS#
		@ Load IER
		@ Disable bit 1 = Tx interrupt enable (Mask THR)
		@ Write to IER
B-- GOBCK	@ Exit to wait for CTS# interrupt
		
@ Unmask THR, send the character, test if more characters
@ SEND

		@ Load pointer to IER
		@ Bit 3 = modem status interrupt, bit 1 = Tx int enable
		@ Write to IER
		@ Load address of char pointer
		@ Load address of desired char in text string
		@ Load address of count store location
		@ Get current char count value
		@ Load char from string, increment char pointer
		@ Put incremented char address into CHAR_PTR fo rnext time
		@ Point at UART THR
		@ Write char to THR, which clears interrupt source for now
		@ Decrement char counter by 1
		@ Store char value counter back in memory
		@ Test char counter value
BPL GOBCK	@ If greater than zero, go get more characters
		@ If not, reload the message. Get address of start string.
		@ Store the string starting address in CHAR_PTR
		@ Load the original number of characters in string again
		@ Write that length to CHAR_CTR
		@ Load address of MCR
		@ Read current value of MCR
		@ Clear bit 3 to disable UART interrupts
		@ Write resulting value with cleared bit 3 back to MCR

@ Restore from the interrupt
@ GOBACK

		@ Restore additional registers
		@ Restore original registers, including return address
		@ Return from interrupt (to wait loop)

 
