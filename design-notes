Design Log

==============================================================================

First, I read through the RC8660 data sheet from the introduction to the serial interface portion on page 10. I drew the IC diagram of the typical application circuit on page 3 and verified that I understood each line. Then I worked with the RS232 section in the text (page 273-275) summarized.

8 bit packets, one start bit, one stop bit, no parity bit
RC8660 handles up to 115200 and automatically detects. 


The logic level conversion is handled by the MAX202 in circuit.

We can connect RS232 straight through. 
The PXA270 has four UARTS. We're using UART B on COM2 (16C554) 
and interfacing with the RC8660 speech synthesizer chip. 

UART is DTE and RC8660 is DCE.

Usually the standard RS232 procedure is:

DTR# -> 
     <- DSR#
RTS# ->
     <- CTS#
     <- CD#

We're not using DSR# and RTS# at all.

The next step is to figure out the actual handshaking procedure.

In this case, the UART 16C554 will have the buffer loaded with ASCII chars when it detects an interrupt - if this was caused by the falling edge on the RC8660 CTS# line, the UART will begin to send the message to the RC8660.

A message consists of a start bit, 8 bits, a stop bit, another start bit, 8 bits, another stop bit, etc. The RC8660 will leave the CTS# line low until the bits are all accepted and then pull the line high. What if the CTS# line is pulled high again during the message?  

RxD and TxD are also included in the datasheet and figure 5-19 -- how are they used?

==============================================================================

Second, I worked through setting up the interrupt handling, leaving the contents of the button service procedure empty. I looked up the GPIO91 info from the datasheet.

For GPIO91,     GPLR2 monitors pin state
                GPSR2 status register
                GPCR2 control register
                GPDR2 set in direction
                GRER2 rising edge detect
                GFER2 falling edge detect
                GEDR2 detect edge type
                from Table 24-4 on page 24-11 of datasheet
                register bitfield definitions on following pages

I want to configure GPIO91 as an input and for rising edge detect. I had the code from my previous project from ECE371 so I walked through that to verify that I still understood it and then I went down and tested it in the lab.

==============================================================================

Third, I developed the .data portion. I looked in the RC8660 to find the format for controls, which I converted to hex, and for data, which I left in ascii. I found it difficult to tell which was which if they were all in ascii.

Command syntax in the RC8660 data sheet is on page 20. The default command character (CTRL+A) is 0x01. I decided to go with their recommendation, which is that I use absolute parameters once and then use relative parameters after that.

For example, this string of absolute parameters sets Alvin voice at volume 7:

CTRL+A "9O" CTRL+A "7V" where CTRL+A is also 01
0x01,0x39,0x30,0x01,0x37,0x56

Data syntax appeared to be ridiculously simple. I started with
'This is a test' in ascii. I started with T,h,i,s, ,i,s, a, ,t,e,s,t to see.

(This is the point where I got excited about the project.)

How to do stop and start bits?

==============================================================================

Fourth, I went into the UART B on COM2 to figure out the order of operations for its interface to the speech chip, first the hardware and then the interrupts.

Notes on first read-through:

We're not using a parity bit.
Baud rate supported by RC8660 is 115200 max.
"Selectable receive FIFO trigger levels, selectable TX and RX baud rates, modem
interface controls." 

Standard CPU interface or using the bus? I don't know.

Standard CPU 16 Mode
UART Channel B (pg 5-39)
CSA CSB CSC CSD
1   0   1   1

Bus 68 Mode
UART CHannel B (pg 5-40)
-CS A4 A3 
 0  0  1

I read through the registers twice. No notes. Just thinking about it.

Then I realized that we're writing to the PXA270, not the RC8660! This has been a constant refrain throughout the project.

==============================================================================

Fourth, I read through the UART initialization procedures on pages 275-278 and verified all of the hex and all of the registers. I made up the following algorithm:

INITIALIZE UART

1. Set baud rate	Write to divisor latches
			Set divisor bit 7 in LCR to 1
			10000011 = 0x83
			Choosing baud rate of 38.4k because RC8660 handles it.
			DLM 0x00
			DLL 0x18
			Reset enable bit 7 in LCR to 0.

2. Generate appropriate interrupt signals
			In the IER, 
				set bit 3 for CTS# asserted
				set bit 1 for when THR is available
				control word: 0x0A

3. Set non-FIFO mode and explicitly clear FIFO	
	FCR is ISR - how can I be sure I'm writing to the correct register?
	In any case, write 0x0 to FCR.

4. Hook IRQ vector, install our INT-DIRECTORY procedure.

* Not sure about steps 5 and 6 at this point. Need to verify hex.

*5. Allow interrupt ocntroller to respond to button press on <75> 
					     and UART on <115>
			Unmask bit 10 in the IMR
			0x40D00004 	control word: __________

*6. Enable UART interrupt inside the BUTTON_SVC program so the button 
	   sends the text message to the RC8660. 

==============================================================================
