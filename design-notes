Design Log

---------------------------------------------

Goal #1 

"Your pulse rate is 52."

Develop a program that sends a basic message to the RC8660 Evaluation Board
on an interrupt basis, when a button connected to GPIO <73> is pressed. Note that
the basic structure of the button-driven talker program is similar to the Button
Service Program in Hall Chapter 5 and the program that you implemented in
Design Project #2 in ECE 371 last term, except that you have to add the code to
send a message to the RC8600. Note that in addition to sending ASCII codes for
desired speech to the RC8600, you will send control codes to the synthesizer to
change the voice used by the synthesizer. Some people like the Darth Vader voice,
for example.

Goal #2

Enhance the program so that when the button is pushed, it uses the RTC alarm
function to send the desired message to the synthesizer every 60 seconds.

Goal #3

Optionally, for extra credit, make the synthesizer do something impressive such as
play music, sing, speak a foreign language, etc.

---------------------------------------------

First, I wanted to figure out this chip. I read through the RC8660 data sheet from the introduction to the serial interface portion on page 10. I drew the IC diagram of the typical application circuit on page 3 and verified that I understood each line. Then I worked with the RS232 section in the text (page 273-275) and summarized:

8 bit packets, one start bit, one stop bit, no parity bit, LSB first
*** Try different baud rates, see if it matters? use the baud rate command.
RC8660 handles up to 115200 and automatically detects. 

Use the CTS# to control the flow but only have to check it every eight bytes because all data is routed through a high speed 16-byte buffer within the chip before being stored in the main buffer.

The logic level conversion is handled by the MAX202 in circuit.

We can connect RS232 straight through. 
The PXA270 has four UARTS. We're using UART B on COM2 (16C554) 
and interfacing with the RC8660 speech synthesizer chip. 

UART is DTE and RC8660 is DCE.

Usually the standard RS232 procedure is:

DTR# -> 
     <- DSR#
RTS# ->
     <- CTS#
     <- CD#

We're not using DSR# and RTS# at all.

The next step is to figure out the actual handshaking procedure.

In this case, the UART 16C554 will have the buffer loaded with ASCII chars when it detects an interrupt - if this was caused by the falling edge on the RC8660 CTS# line, the UART will begin to send the message to the RC8660.

A message consists of a start bit, 8 bits, a stop bit, another start bit, 8 bits, another stop bit, etc. The RC8660 will leave the CTS# line low until the bits are all accepted and then pull the line high. What if the CTS# line is pulled high again during the message? 

RxD and TxD are also included in the datasheet and figure 5-19 -- how are they used?

---------------------------------------------

Second, I worked through setting up the interrupt handling, leaving the contents of the button service procedure empty. I looked up the GPIO73 info from the datasheet.

For GPIO73,     GPLR2 monitors pin state
                GPSR2 status register
                GPCR2 control register
                GPDR2 set in direction
                GRER2 rising edge detect
                GFER2 falling edge detect
                GEDR2 detect edge type
                from Table 24-4 on page 24-11 of datasheet
                register bitfield definitions on following pages

I want to configure GPIO73 as an input and for rising edge detect. I had the code from my previous project from ECE371 so I walked through that to verify that I still understood it and then I went down and tested it in the lab.

---------------------------------------------

Third, I developed the .data portion. I looked in the RC8660 to find the format for controls, which I converted to hex, and for data, which I left in ascii. I found it difficult to tell which was which if they were all in ascii.

Command syntax in the RC8660 data sheet is on page 20. The default command character (CTRL+A) is 0x01. I decided to go with their recommendation, which is that I use absolute parameters once and then use relative parameters after that.

For example, this string of absolute parameters sets Alvin voice at volume 7:

CTRL+A "9O" CTRL+A "7V" where CTRL+A is also 01
0x01,0x39,0x30,0x01,0x37,0x56

Data syntax appeared to be ridiculously simple. I started with
'This is a test' in ascii. I started with T,a,k,e, ,m,e, t,o, ,y,o,u,r, ,l,e,a,d,e,r to see.

(This is the point where I got excited about the project.)

How to do stop and start bits? 

---------------------------------------------

Fourth, I went into the UART B on COM2 to figure out the order of operations for its interface to the speech chip, first the hardware and then the interrupts.

Notes on first read-through:

We're not using a parity bit.
Baud rate supported by RC8660 is 115200 max.
"Selectable receive FIFO trigger levels, selectable TX and RX baud rates, modem
interface controls." 

Standard CPU interface or using the bus? I don't know.

Standard CPU 16 Mode
UART Channel B (pg 5-39)
CSA CSB CSC CSD
1   0   1   1

Bus 68 Mode
UART CHannel B (pg 5-40)
-CS A4 A3 
 0  0  1

I read through the registers twice. No notes. Just thinking about it.

Then I realized that we're writing to the PXA270, not the RC8660! I keep getting this confused. I drew all the physical pieces out on the white board to get it straight.

---------------------------------------------

I read through the UART initialization procedures on pages 275-278 and verified all of the hex and all of the registers. I made up the following algorithm:

INITIALIZE UART B in the external 16C554 using COM2 port: 

1. Set baud rate	Write to divisor latches
			Set divisor bit 7 in LCR to 1
			10000011 = 0x83
			Choosing baud rate of 38.4k because RC8660 handles it.
			DLM 0x00
			DLL 0x18
			Reset enable bit 7 in LCR to 0.

2. Generate appropriate interrupt signals
			In the IER, 
				set bit 3 for CTS# asserted
				set bit 1 for when THR is available
				control word: 0x0A

3. Set non-FIFO mode and explicitly clear FIFO	
	FCR is ISR - how can I be sure I'm writing to the correct register?
	In any case, write 0x0 to FCR.

4. Hook IRQ vector, install our IRQ-DIRECTORY procedure.

* Not sure about steps 5 and 6 at this point. Need to verify hex.

*5. Allow interrupt controller to respond to button press on <75> 
					     and UART on <115>
			Unmask bit 10 in the IMR
			0x40D00004 	control word: __________

*6. Enable UART interrupt inside the BUTTON_SVC program so the button 
	   sends the text message to the RC8660. 

---------------------------------------------

Fifth! Having worked out the details of my version of the program, I stepped back to put all the pieces together in an algorithm version using the program in figure 5-27, my interrupt pieces from my buttom program that I know are correct, and the notes I've made up til now about the registers for my GPIO pins.

I realized that the interrupt steps that I have and the ones Dr. Hall has in figure 5-27 didn't entirely agree ... but realized after walking through registers that they were just out of order and order didn't matter for that case, as the values were already written back before the registers were changed.

I also had to step through every register (I made a diagram on the whiteboard) in the button service and talker service portions to be sure I covered the cases in the correct order, and that there weren't any surprises in the text code.

The final version of that was basically sections, which I then drew up in the algorithm/flow chart that's attached. Then I worked through each section, cross-referencing with the book, until I had everything branching correctly. Then I added in the actual register-level comments.

Final version of this was all the comments in the part one. 

---------------------------------------------

Before filling in the rest of the actual code to the left of the @ symbols, I went through and changed all the branch names so they were consistent. I verified the process again by walking through each step in the algorithm and making sure all the values were loaded and stored properly. I cleaned up the comments and tried to make them more simple.

Then I printed out the algorithm so far and, starting at the top, I worked through and calculated all the register address values and wrote them in at each step. I then collected them all in a giant list to be defined at the beginning of the program. 

I realized that I didn't actually know what the CPSR, ICIP, etc. addresses should be so I went back through the text and reviewed all the interrupt stuff from chapter four, comparing it line by line with the IRQ procedure hook section from ZeusTalker.s on pages 310-312. I made sure to include the BTLDR_IRQ_ADDRESS in the literal pool but I'm still not sure about where CPSR came from. 

Then I walked through each section and wrote the code.

I got a little lost in the bit sets and clears and had to use some diagrams to figure out what I was doing. Then I remembered what BIC does. Also had to look up MRS and MSR to make sure Dr Hall's syntax was correct.

I basically used the given #0x83 and #0x18 values for the UART straight from the text. Probably need to check it against the UART datasheet but at this point I just want to see if it works on the first try.

Decided maybe only need R0, R1 and not the extra registers that are called for in Hall's program. Worked out the talker service and realized, no, you need them for the message and counter.

Also, the BNE and BEQ were switched.

---------------------------------------------

I set the message to be "take me to your leader" and need to go down to the lab to test it.

---------------------------------------------
