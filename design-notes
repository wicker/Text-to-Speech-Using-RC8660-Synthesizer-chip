Design Log

==============================================================================

First, I read through the RC8660 data sheet from the introduction to the serial interface portion on page 10. I drew the IC diagram of the typical application circuit on page 3 and verified that I understood each line. Then I worked with the RS232 section in the text (page 273-275) summarized.

8 bit packets, one start bit, one stop bit, no parity bit
RC8660 handles up to 115200 and automatically detects. 


The logic level conversion is handled by the MAX202 in circuit.

We can connect RS232 straight through. 
The PXA270 has four UARTS. We're using UART B on COM2 (16C554) 
and interfacing with the RC8660 speech synthesizer chip. 

UART is DTE and RC8660 is DCE.

Usually the standard RS232 procedure is:

DTR# -> 
     <- DSR#
RTS# ->
     <- CTS#
     <- CD#

We're not using DSR# and RTS# at all.

The next step is to figure out the actual handshaking procedure.

In this case, the UART 16C554 will have the buffer loaded with ASCII chars when it detects an interrupt - if this was caused by the falling edge on the RC8660 CTS# line, the UART will begin to send the message to the RC8660.

A message consists of a start bit, 8 bits, a stop bit, another start bit, 8 bits, another stop bit, etc. The RC8660 will leave the CTS# line low until the bits are all accepted and then pull the line high. What if the CTS# line is pulled high again during the message?  

RxD and TxD are also included in the datasheet and figure 5-19 -- how are they used?

==============================================================================

Second, I worked through setting up the interrupt handling, leaving the contents of the button service procedure empty. I looked up the GPIO91 info from the datasheet.

For GPIO91,     GPLR2 monitors pin state
                GPSR2 status register
                GPCR2 control register
                GPDR2 set in direction
                GRER2 rising edge detect
                GFER2 falling edge detect
                GEDR2 detect edge type
                from Table 24-4 on page 24-11 of datasheet
                register bitfield definitions on following pages

I want to configure GPIO91 as an input and for rising edge detect. I had the code from my previous project from ECE371 so I walked through that to verify that I still understood it and then I went down and tested it in the lab.

==============================================================================

Third, I developed the .data portion. I looked in the RC8660 to find the format for controls, which I converted to hex, and for data, which I left in ascii. I found it difficult to tell which was which if they were all in ascii.

Command syntax in the RC8660 data sheet is on page 20. The default command character (CTRL+A) is 0x01. I decided to go with their recommendation, which is that I use absolute parameters once and then use relative parameters after that.

For example, this string of absolute parameters sets Alvin voice at volume 7:

CTRL+A "9O" CTRL+A "7V" where CTRL+A is also 01
0x01,0x39,0x30,0x01,0x37,0x56

Data syntax appeared to be ridiculously simple. I started with
'This is a test' in ascii. I started with T,h,i,s, ,i,s, a, ,t,e,s,t to see.

(This is the point where I got excited about the project.)

How to do stop and start bits?

==============================================================================




